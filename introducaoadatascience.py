# -*- coding: utf-8 -*-
"""IntroducaoAdataScience.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Z8_FSWnO6Q_FwbLNBOW5vYwDR68bk5vP

#ANALISANDO NOTAS EM GERAL
"""

import seaborn as sns

sns.boxplot(notas.nota)

import pandas as pd

notas = pd.read_csv("ratings.csv")
notas.head()

notas.shape # shape quer dizer formtao, ent tem 1000836 avaliacoes em 4 colunas

notas.columns = ["UsuarioID","FilmeID","nota","momento"]
notas.head()

notas['nota']

notas['nota'].unique()#unique vai unificar as variaveis de notas que tivemos

notas['nota'].value_counts()#value counts conta quantas vvezes cada nota foi dada

notas['nota'].mean()

notas.nota.head()

notas.nota

notas.nota.plot()

notas.nota.plot(kind= 'hist')

print("Media",notas['nota'].mean())
print("Mediana",notas['nota'].median())

notas.nota.describe()

"""#olhando os filmes

"""

filmes = pd.read_csv("movies.csv")
filmes.columns = ["FilmeID", "Titulo","Generos"]#alterando para portugues as colunas
filmes.head()

notas.head()#head mostra a cabeca(5 primeiros indices)

"""# ANALISANDO NOTAS ESPECIFICAS POR FILME"""

notas.query("FilmeID==1").nota.mean()

notas.query("FilmeID==1").nota

notas.query("FilmeID==1")

notas.query("FilmeID==2").nota.mean()

medias_por_filme = notas.groupby("FilmeID").mean()["nota"]#agrupe notas do filmeID e me de a media de Nota
medias_por_filme.head()

medias_por_filme.plot(kind='hist')

sns.boxplot(medias_por_filme)# grafico representando a media, a barra no meio azul é a mediana

medias_por_filme.describe()#describe serve para descrever oq tem na categoria

import matplotlib.pyplot as plt
plt.figure(figsize=(8,9))#determinando o tamnho do grafico
sns.distplot(medias_por_filme)

plt.hist(medias_por_filme)#hist = vai contar uma historia sobre (medias por filme)
plt.title("Histogra das Medias dos Filmes")

plt.title("Histogra das Medias dos Filmes")#define o titulo do grafico

tmdb = pd.read_csv("tmdb_5000_movies.csv")
tmdb.head()

tmdb.original_language.unique() #categorica nominal #As variáveis categóricas são aquelas que não possuem valores quantitativos, mas, ao contrário,
# são definidas por várias categorias, ou seja, representam uma classificação dos indivíduos. Podem ser nominais ou ordinais.

#primiero grau
#segundo grau
#terceiro grau
# 1 grau < 2 grau < 3 grau # CATEGORICA ORDINAL - ordinal pq possui uma ordem

# Quando estamos trabalhando com categorias ordinais, existe uma ordenação entre as categorias. Por exemplo: escolaridade (primeiro, segundo e terceiro graus),
# estágios de uma doença (inicial, intermediário, terminal), mês de observação (janeiro, fevereiro, ..., dezembro), etc.

# budget =>orcamento => quantitativa continuo

# quantidade de votos => 1, 2, 3, 4, nao tem 2.5 votos.
# notas do movielens => 0.5,1,1.5 ... , 5 nao tem 2.7

tmdb.original_language.value_counts()#contar os valores, quantas vezes cada lingua aparece, é considerada uma serie pq nao nao contamos o indice

tmdb.original_language.value_counts().index

tmdb.original_language.value_counts().values

tmdb.original_language.value_counts().to_frame()#transforma em um data frame

contagem_de_linguas = tmdb.original_language.value_counts().to_frame().reset_index()#quebro o indice que tinha e agora tenho duas colunas,index e original language
contagem_de_linguas.columns = ["original_language","total"]
contagem_de_linguas.head()

sns.barplot(x = "original_language", y = "total" ,data = contagem_de_linguas)#plot = exibir, eixo X horizontal, eixo Y na vertical, primeiro transformei e data frame para conseguir usar o plot tendo x e y

#Resumindo tudo que eu fiz convertendo com o catplot
sns.catplot(x= "original_language", kind="count", data = tmdb)#catplot no eixo x use o original languagem q foi a categoria e com o KIND(TIPO) conte quantas vezes apareceu

# Nas variacoes de maquinas virtuais as versoes das bibliotecas podem estar atualizadas ou desatualizadas, para instalar uma especifica esse é o comando
# print(sns.__version__) verifica versao, !pip install seaborn == 0.9.0 ou a versao depois
# import seaborn as sns e imprime dnv pra checar e restart o run time no ambiente de execucao ou run time se tiver em ingles

plt.pie(contagem_de_linguas["total"], labels = contagem_de_linguas["original_language"]) # Não é o mais ideal pois é muito dificil de se comparar a olho nu
# grafico de torta,pizza é um grafico de area

total_por_lingua = tmdb["original_language"].value_counts()
total_geral = total_por_lingua.sum()
total_de_ingles = total_por_lingua.loc["en"]#localizar por lingua o indice igual a EN
total_do_resto = total_geral - total_de_ingles
print(total_geral,total_do_resto)

dados = {
    'lingua' : ['ingles','outros'],
    'total' : [total_de_ingles,total_do_resto]
}
dados #Criei uma biblioteca em python

pd.DataFrame(dados)

sns.barplot(x="lingua", y="total", data = dados) #Comparativo com a biblioteca Dados sendo X lingua na vertical e Y total na horizontal

plt.pie(dados["total"], labels = dados["lingua"]) # Grafico de Pizza comparando o total que foi definido na biblioteca DADOS sendo total_de_ingles e total_do_resto
#Labels sao as etiquetas,os nomes apontando cada variavel ali

total_por_lingua_outros_filmes = tmdb.query("original_language != 'en' ").original_language.value_counts() # Variavel que conta o total por lingua sem o Ingles
total_por_lingua_outros_filmes

filmes_sem_lingua_original_em_ingles = tmdb.query("original_language != 'en' ") #Definindo variavel que tira o ingles
sns.catplot(x= "original_language", kind="count", data = filmes_sem_lingua_original_em_ingles,#Repliquei o grafico mas agora SEM O INGLES EM LINGUAS
            aspect = 2, #Arrumei oq tava sempre um em cima do outro dando Espaco de 2 com aspect
            palette = "GnBu_d", # Mudei a paleta de cores no site do seaborn tem todas, usando palette
            order = total_por_lingua_outros_filmes.index) # Defini a ordem com uma varival que ja tinha calculado acima

"""# Revisando Papel Da media,mediana,medidas de tendencia central,dispersao,desvio padrao,bloxplot e histograma


"""

filmes.head(2)#head mostra 5,2 mostra so 2

notas_do_toyStory = notas.query("FilmeID == 1")
notas_do_Jumanji = notas.query("FilmeID == 2")
print(len(notas_do_toyStory), len(notas_do_Jumanji))#Len conta quantidade, to contando quantas notas tem do toyStory e Quantas tem d Jumanji

print("Nota Media do ToyStory %.2f" % notas_do_toyStory.nota.mean() ) # Printei a media de nota do toystory,boas praticas pra arredondar com %.2f e aqui % apos o texto
print("Nota Media do Jumanji %.2f" % notas_do_Jumanji.nota.mean() )

print("Nota Media do ToyStory %.2f" % notas_do_toyStory.nota.median() ) # Printei a mediana de nota do toystory,boas praticas pra arredondar com %.2f e aqui % apos o texto
print("Nota Media do Jumanji %.2f" % notas_do_Jumanji.nota.median() )

import numpy as np

filme1 = np.append (np.array([2.5]*10), np.array([3.5]*10)) #NP.ARRAY cria uma sequencia, escolhi q seja de 2.5 e 10 vezes,exemplo 10 pessoas deram nota 2.5 e outras 10 3.5
filme2 = np.append (np.array([5]*10), np.array([1]*10))# seguindo a logica 10 pessoas deram 5 e 10 1 para o filme 2, o append serve pra concatenar (somar)

print(filme1.mean(), filme2.mean())# as medias sao iguais porem a distribuicao de notas sao completamente diferentes
print(np.std(filme1),np.std(filme2))# o desvio padrao entre votos,no primeiro filme é de meio e no segundo de 2,sendo muito maior o desvio
print(np.median(filme1), np.median(filme2))#ao contrario do padrao de filme1.median no nunpy se precisa chamar a funcao primeiro

plt.hist(filme1)#plot do meu histograma,filme 1 em azul,filme 2 em laranja
plt.hist(filme2)

plt.boxplot([filme1,filme2])

plt.boxplot([notas_do_toyStory.nota,notas_do_Jumanji.nota])

print(notas_do_toyStory.nota.std(),notas_do_Jumanji.nota.std() )#.std calcula o desvio padra em ingles Standart deviatian